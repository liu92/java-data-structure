
`一、数据基本信息`

`1、数据、数据元素、数据项和数据对象`
  a、数据 
     .是能输入计算机且能被计算机处理的各种符合的集合
       * 信息的载体
       * 是对客观事物符号化的表示
       * 能够被计算机识别、存储和加工
     
     .包括:
       * 数值型的数据：整数、实数等
       * 非数值型的数据：文字、图像、图形、声音等
     
  b、数据元素
     . 是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理      
     . 也简称为元素，或称为记录，结点或顶点。 
     . 一个数据元素可由若干数据项组成
     
  c、数据项
     . 构成数据元素的不可分割的最小单位。
     
  d、数据对象
     . 是性质相同的数据元素的集合，是数据的一个子集。   
     
  e、数据类型
     例如C语言中：
      * 提供 int、char、float、double等基本数据类型
      * 数组、结构、共用体、枚举等构造数据类型
      * 还有指针、空（void）类型
      * 用户还可以用typedef来自己定义数据类型  
     
`2、什么是数据结构`
   a、数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系成为结构
   b、是指相互之间存在一种或多种特定关系的数据元素集合
   c、或者说，数据结构是带结构的数据元素的集合
2.1、数据结构包括以下三个方面的内容：
   a、数据元素之间的逻辑关系，也称为逻辑结构
   b、数据元素及其关系在计算机内存中的表示（又称为映像），称为数据的物理结构或数据的存储结构。
   c、数据的运算和实现，即对数据元素可以施加的操作以及这些操作在想要的存储结构上的实现
2.2 数据结构的两个层次
   a.逻辑结构 
     * 描述数据元素之间的逻辑关系
     * 与数据的存储无关，独立于计算机
     * 是从具体问题抽象出来的数学模型
   b.物理结构（存储结构）
     * 数据元素及其关系在计算机存储器中的结构（存储方式）
     * 是数据结构在计算机中的表示
   c.逻辑结构与存储结构的关系
     * 存储结构是逻辑关系的映像与元素本身的映像。
     * 逻辑结构是数据结构的抽象，存储结构是数据结构的实现
     * 两者综合起来建立了数据元素之间的结构关系。    
2.3、逻辑结构的种类
    划分方式一
    1)、线性结构
        有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继
         例如：线性表、栈、队列、串
    2)、非线性结构
        一个结点可能有多个直接前趋和直接后继
         例如：树、图           
    划分方式二
    1)、集合结构：结构中的数据元素之间除了同属于一个集合的关系外，无任何其他关系
    2)、线性几个：结构中的数据元素之间存在一对一的线性关系
    3)、树形结构：结构中的数据元素之间存在着一对多的层次关系
    4)、图状结构或网状结构：结构中的数据元素之间存在着多对的的任意关系。
    
2.4、存储结构的种类
    1)、顺序存储结构
         * 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。
         * C 语言中用数组来实现顺序存储结构
    2)、链式存储结构
        * 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。
        * C 语言中用指针（地址）来实现链式存储结构
    3)、索引存储结构
       * 在存储结点信息的同时，还建立附加的索引表。
       * 索引表的每一项称为一个索引项
       * 索引项的一般形式是：（关键字，地址）
       * 关键是能唯一标识一个结点的那些数据项。
    4)、散列存储结构     
       * 根据结点的关键字直接计算出该结点的存储地址
2.5 用C语言实现抽象数据类型
``
 void assign(Complex *A , float real, float image){
   A ->realpart = real; //实部
   A ->imagepart = imag; // 虚部
 }
 
 void add(Complex *c, Complex A, Complex B){
   c -> realpart = A.realpart + B.realpart;
   c -> imagepart = A.imagepart + B.imagepart;
 }
 注:Complex 是我们定义的一个结构类型
  带*：表示指针变量，他是指向Complex类型的指针
  不带*：Complex类型的普通变量
``     
     
2.6、算法
1)、算法的定义：对特定问题求解方法和步骤的一种描述，它是指令的有限序列，其中每个指令表示一个或多个操作     
2)、算法与程序：
   *算法是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法
   *程序是用某种程序设计语言对算法的具体实现
3)、算法特性 ：一个算法必须具备以下五个重要特性
  * 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成
  * 确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有
       唯一的一条执行路径，即对于相同的输入只能得到相同的输出
  * 可行性： 算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现
  * 输入 ： 一个算法有零个或多个输入
  * 输出 ： 一个算法一个多个多个输出
      
4)、算法设计的要求
  * 正确性（Correctness）
  * 可读性（Readability）
  * 健壮性（Robustness）
  * 高效性（Efficiency）  
  
5)、算法时间复杂度的渐进表示法
  * 为了便于比较不同算法的时间效率，我们仅比较它们的数量级
    例如：两个不同的算法，时间消耗分别是：
      T1(n) = 10n^2 与 T2(n) = 5n^3  
6)、若某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，
     则称f(n)是T(n)的同数量级函数。记作T(n) =O(f(n)), 称O(f(n))为算法的渐进时间复杂度(O是数量级的符号)，简称时间复杂度。
 ```
例如：对于求解矩阵相乘问题，算法耗费时间：
        T(n) = 2n^3 + 3n^2 + 2n +1
        当n--->无穷大时，T(n)/n^3 -->2,这表示n充分大时，T(n)与n^3是同阶或同数量级，引入大“O”记号，则T(n)可以记作：
            T(n)= O(n^3)  这就是求解矩阵相乘问题的算法的渐进时间复杂度 

 ```  
7)、 一般情况下，不必计算所有操作的执行次数，而只考虑算法中基本操作执行的次数，它是问题规模n的某个函数，用T(n)表示。
     
8)、算法时间复杂度的定义
    *算法中基本语句重复执行的次数是问题规模n的某个函数f(n),算法的时间量度记作：T(n)=O(f(n))
      a、算法中重复执行次数和算法的执行时间成正比的语句
      b、对算法运行时间的贡献最大的
      c、执行次数最多的     
      
    对应n 越大算法的执行时间越长
     *排序：n为记录数
     *矩阵：n为矩阵的阶数
     *多项式：n为多项式的项数
     *集合：n为元素个数
     *树：n为树的结点个数
     *图：n为图的顶点数或边数
9)、分析算法时间复杂度的基本方法
    a、找出语句频度最大的那条语句作为基本语句
    b、计算基本语句的频度得到问题规模n的某个函数f(n)
    c、取其数量级用符号“O”表示
```
x=0; y=0;
 for(int k=0;k<n;k++){ // for循环是n+1次，循环体是n次
  x++;
}

```

例2：N*N矩阵相乘
![image](image/image-5538.png)   

算法时间复杂度分析示例
![image](image/image-1227.png)   
  
算法时间复杂度分析例题，示例3
![image](image/image-1746.png)   
    
  
10) 渐进空间复杂度
  * 空间复杂度：算法所需存储空间的度量， 记作：S(n)=O(f(n))  其中n为问题的规模(或大小)
  * 算法要占用的空间
     a.算法本身要占据的空间，输入/输出，指令，常数，变量等
     b.算法要使用的辅助空间
     
2.7、知识回顾小结
     1、数据结构 
      a.数据的逻辑结构
          * 线性结构:
              线性表
              栈(特殊线性表)
              队列
              字符串、数组、广义表
          * 非线性结构:
              树形结构
              图形结构   
      b.数据的存储结构
          * 顺序存储
          * 链式存储
      c.数据的运算  
          * 检索、排序、插入、删除、修改等
          
3、线性表要研究的内容
   a.线性表的定义和特点
   b.案例引入
   c.线性的类型定义
   d.线性表的顺序表示和实现2
   e.线性表的链式表示和实现
   f.顺序表和链表的比较
   g.线性表的应用
   h.案例分析与实现
   
3.1线性表的定义和特点
  线性表示具有相同特性的数据元素的一个有限序列 
![image](image/image-0102.png)              
1、线性表(Linear List)
 ![image](image/image-1235.png) 
   
3.2、案例引入
 案例:一元多项式的运算，实现两个多项式加、减、乘运算  
 ![image](image/image-2000.png)
 
 稀疏多项式:存储是就不根据上面的方法来存储了，因为按照那种方式存储会操作空间浪费
  ![image](image/image-3229.png)
 稀疏多项式的运算
 ![image](image/image-3942.png)
 注意: 稀疏多项式运算
      1、创建一个新的数组c
      2、分别从头遍历比较a和b的每一项
         *指数相同，对应系数相加，若相加不为零，则在c中增加一个新项
         *指数不相同，则将指数较小的项复制到c中
         
 顺序存储结构存在问题
   1、存储空间分配不灵活
   2、运算的空间复杂度高
   
3.3、线性的类型定义
  1、抽象数据类型线性表的定义如下：
   ![image](image/image-0119.png)
  2、InitList(&L) (Initialization List)
   操作结果:构造一个空的线性表L
  3、DestroyList(&L)
   * 初始条件:线性表L已经存在
   * 操作结果:销毁线性表
  4、ClearList(&L)
   * 初始条件:线性表L已经存在。
   * 操作结果:将线性表L重置为空表。
  5、ListEmpty(L)
   * 初始条件:线性表L已经存在。
   * 操作结果:若线性表L为空表,则返回TRUE;否则返回FALSE。     
  6、ListLength(L)
   * 初始条件:线性表L已经存在。
   * 操作结果:返回线性表L中的数据元素个数。  
  7、GetElem(L,i,&e)  (加上&表示要返回值)
   * 初始条件:线性表L已经存在,1<=i<=ListLength(l)。
   * 操作结果:用e返回线性表L中第1个数据元素的值。
  8、LocateElem(L,e,compare())
   * 初始条件:线性表L已经存在,compare()是数据元素判定函数。
   * 操作结果:返回L中第1个与e满足compare的数据元素的位序,若这样的数据元素不存在则返回值为0。
  9、PriorElem(L,cur_e,&pre_e)
   * 初始条件:线性表L已经存在。
   * 操作结果:若cur_e是L的数据元素,且不是第1个，则用pre_e返回它的前趋否则操作失败,pre_e无意义。  
  9、NextElem(L,cur_e,&next_e)
    * 初始条件:线性表L已经存在。
    * 操作结果:若cur_e是L的数据元素,且不是最后一个，则用next_e返回它的后继否则操作失败,next_e无意义。
  10、ListInsert(&L,i,e)
     * 初始条件:线性表L已经存在,1<=i<=ListLength(L)+1。
     * 操作结果:在L的第i个位置之前插入新的数据元素e,L的长度加1   
  11、ListDelete(&L,i,&e)
      * 初始条件:线性表L已经存在,1<=i<=ListLength(L)。
      * 操作结果:删除L的第i个数据元素,并用e返回其值,L的长度减一。   
  12、ListTraverse(&L,visited())
       * 初始条件:线性表L已经存在。
       * 操作结果:依次对线性表中每个元素调用visited()。   
 
3.4、线性表的顺序存储表示
   线程表的顺序表示又称为顺序存储结构或顺序映像
   a、顺序存储定义:把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构
![image](image/image-4323.png)

3.4.1、顺序表的顺序存储表示
![image](image/image-20200509140440.png)
 定义多项式的结构，然后去计算多项式。
![image](image/image-20200509140808.png)

3.5 补充 类c语言的有关操作
 a、对一些问题的补充说明
  ![image](image/image-20200509143202.png)                                      
 
 b、C语言的内存动态分配
  (Sequence List) 顺序表，下面的SqList L 定义变量，L是SqList这种类型的。
  这个就像 int a; //定义变量a, a是int型。
  SqList L;
   L.data=(ElemType*)malloc(sizeof(ElemType)*MaxSize);  
   这里ElemType*, *表示指针 这里进行了强制类型转换。
  1)、malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址, 参数要求是整数
  2)、sizeof(x)运算，计算变量x的长度
  3)、free(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量
  
  这些函数在头文件里面，所以需要加载头文件:<stdlib.h>  
 
3.5.1 C++中参数传递
  1、函数调用时传送给形参表的实参必须与形参三个一致 
     类型、个数、顺序
  2、参数传递有两种方式
     * 传值方式(参数为整型、实型，字符型等)
     * 传地址
         参数为指针变量
         参数为引用类型
         参数为数组名 
         
 a、传值方式:把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。
  函数修改的是副本的值，实参的值不变。
  ![image](image/image-20200509150056.png)
  
b、传地址方式---指针变量作为参数
  * 形参变化影响实参
    这个指针指向的就是这个参数地址位置
   这里方式是改变指针指向的内容
![image](image/image-20200509151040.png)
 
  *形参变化不影响实参??
   这里只是改变指向，但是不改变指针指向的地址
 ![image](image/image-20200509151505.png)
    
    
c、传地址方式--数组名作为参数
  *传递的是数组的首地址
  *对形参数组所做的任何改变都将反映到实参数组中

d、传地址方式-- 引用类型做参数
  引用:它用来给一个对象提供一个替代的名字
```
#include<iostream.h>
void main(){
   int i=5;
   int &j=i;
   i=7;
   count<<"i="<<i<<" j="<<j;
}

这里j是一个引用类型，代表i的一个替代名i值改变是，j值也跟着改变，所以会输出i=7 j=7

```       

e、引用类型作为形参的三点说明
 (1).传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化
 (2).引用类型作参数，在内存中并没有产生实参的副本，它直接对实参操作;
    而一般变量作参数，形参与实参就占用不同的存储单元，所以形参变量的值是实参变量的副本。
    因此，当参数传递的数据量较大时，用引用比用一般变量传递参数的时间和空间效率都好    
 (3).指针参数虽然也能达到与使用引用的效果，但在被调用函数中需要重复使用
   "*指针变量名(取这个指针变量的内容)"的形式进行运算，这很容易产生错误且程序的阅读性较差;另一方面，
   在主调函数的调用点处，必须用变量的地址作为实参。    
   
3.6线性表的顺序表示和实现
  顺序表示意图
  ![image](image/image-20200509154801.png)  
  
补充:操作算法中用到的预定义常量和类型
```
//函数结果状态代码
#define TRUE  1
#define FALSE 0
#define OK    1 
#define ERROE 0
#define INFEASIBLE -1
#define OVERFLOW   -2
//Status 是函数类型，其值是函数结果状态代码
typedef int Status;
typedef char ElemType;
```   
3.6.1 顺序表基本操作的实现
 【算法2.1】 线性表L的初始化(参数用引用类型)
```
 //这里参数应的是引用型的，也就是说这里对形参进行操作实际上也对实参进行了操作
 Status InitList_Sq(SqList &L){ // 构造一个空的顺序表L
  L.elem = new ElemType[MAXSIZE]; // 为顺序表发分配空间
  if(!L.elem) exit(OVERFLOW);  //存储分配失败
  L.length=0;                  //空表长度为0
  return OK; 
}
```             
3.7 顺序表上的查找操作
  a.按值查找:按照给定的运算进行查找,从头到尾一个一个的查找
  算法示例: 
  ![image](image/image-20200509164812.png)
  
  b. 平均查找长度ASL(Average Search Length)
     *为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值叫做查找算法的凭据查找长度
   平均查找长度公式:  这个公式中大E是累加和，P表示第i个记录被查询的概率
     C表示第i个记录需比较的次数。
   ![image](image/image-20200509170041.png)  
    
   公式的推导:每个元素的概率提取出来，然后在进行元素相加，这个是等差数列求和。所以最终的公式如图
   ![image](image/image-20200509170632.png)
             
3.8、插入算法如果在顺序表上表现出来
 顺序表的插入
 ![image](image/image-20200509173101.png)
 算法的实现
 注意：这里的i是位序，不是数组下标
 ``` 
 Status ListInsert_Sq(SqList &L,int i,ElemType e){ // 构造一个空的顺序表L
  if(i<1 || i>L.length+1) return ERROR; //i值不合法 
  if(L.length == MAXSIZE) return ERROR;  //当前存储空间已满
  for(j=L.length-1;j>=i-1;j--){
   L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移
  }
   L.elem[i-1] = e;      //将新元素e放入第i个位置
   L.length++;           //表长增加1
   return OK;
   
 }
```
算法时间主要耗费在移动元素的操作上
 * 若插入在尾结点之后，则根本无需移动(特别快);
 * 若插入在首结点之前，则表中元素全部后移(特别慢);
 * 若要考虑在各种位置插入(共n+1中可能)的平均移动次数，该如何计算?
 ![image](image/image-20200509175127.png)
 *顺序表插入算法的平均时间复杂度为O(n)
 
3.9、顺序表的删除算法。          